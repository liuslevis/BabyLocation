<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0049)http://docs.jinkan.org/docs/flask/quickstart.html -->
<html xmlns="http://www.w3.org/1999/xhtml" slick-uniqueid="3"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    
    <title>快速入门 — Flask 0.10.1 文档</title>
    
    <link rel="stylesheet" href="./flask0.10_files/flasky.css" type="text/css">
    <link rel="stylesheet" href="./flask0.10_files/pygments.css" type="text/css">
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.10.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script><style type="text/css"></style>
    <script type="text/javascript" src="./flask0.10_files/jquery.js"></script>
    <script type="text/javascript" src="./flask0.10_files/underscore.js"></script>
    <script type="text/javascript" src="./flask0.10_files/doctools.js"></script>
    <script type="text/javascript" src="./flask0.10_files/translations.js"></script>
    <link rel="top" title="Flask 0.10.1 文档" href="http://docs.jinkan.org/docs/flask/index.html">
    <link rel="next" title="教程" href="http://docs.jinkan.org/docs/flask/tutorial/index.html">
    <link rel="prev" title="安装" href="http://docs.jinkan.org/docs/flask/installation.html">
   
  
  <link rel="apple-touch-icon" href="http://docs.jinkan.org/docs/flask/_static/touch-icon.png">
  
  <link media="only screen and (max-device-width: 480px)" href="./flask0.10_files/small_flask.css" type="text/css" rel="stylesheet">
  <script src="./flask0.10_files/functions.js" type="text/javascript"></script>

  <style>[touch-action="none"]{ -ms-touch-action: none; touch-action: none; }[touch-action="pan-x"]{ -ms-touch-action: pan-x; touch-action: pan-x; }[touch-action="pan-y"]{ -ms-touch-action: pan-y; touch-action: pan-y; }[touch-action="scroll"],[touch-action="pan-x pan-y"],[touch-action="pan-y pan-x"]{ -ms-touch-action: pan-x pan-y; touch-action: pan-x pan-y; }</style><style id="clearly_highlighting_css" type="text/css">/* selection */ html.clearly_highlighting_enabled ::-moz-selection { background: rgba(246, 238, 150, 0.99); } html.clearly_highlighting_enabled ::selection { background: rgba(246, 238, 150, 0.99); } /* cursor */ html.clearly_highlighting_enabled {    /* cursor and hot-spot position -- requires a default cursor, after the URL one */    cursor: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--cursor.png") 14 16, text; } /* highlight tag */ em.clearly_highlight_element {    font-style: inherit !important; font-weight: inherit !important;    background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--yellow.png");    background-repeat: repeat-x; background-position: top left; background-size: 100% 100%; } /* the delete-buttons are positioned relative to this */ em.clearly_highlight_element.clearly_highlight_first { position: relative; } /* delete buttons */ em.clearly_highlight_element a.clearly_highlight_delete_element {    display: none; cursor: pointer;    padding: 0; margin: 0; line-height: 0;    position: absolute; width: 34px; height: 34px; left: -17px; top: -17px;    background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--delete-sprite.png"); background-repeat: no-repeat; background-position: 0px 0px; } em.clearly_highlight_element a.clearly_highlight_delete_element:hover { background-position: -34px 0px; } /* retina */ @media (min--moz-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2) {    em.clearly_highlight_element { background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--yellow@2x.png"); }    em.clearly_highlight_element a.clearly_highlight_delete_element { background-image: url("chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/clearly/images/highlight--delete-sprite@2x.png"); background-size: 68px 34px; } } </style></head>
  <body>
  
  

    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="http://docs.jinkan.org/docs/flask/genindex.html" title="总目录" accesskey="I">索引</a></li>
        <li class="right">
          <a href="http://docs.jinkan.org/docs/flask/tutorial/index.html" title="教程" accesskey="N">下一页</a> |</li>
        <li class="right">
          <a href="http://docs.jinkan.org/docs/flask/installation.html" title="安装" accesskey="P">上一页</a> |</li>
        <li><a href="http://docs.jinkan.org/docs/flask/index.html">Flask 0.10.1 文档</a> »</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="quickstart">
<span id="id1"></span><h1>快速入门<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#quickstart" title="永久链接至标题">¶</a></h1>
<p>迫不及待要开始了吗？本页提供了一个很好的 Flask 介绍，并假定你已经安装好了 Flask。如果没有，请跳转到 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/installation.html#installation"><em>安装</em></a> 章节。</p>
<div class="section" id="id2">
<h2>一个最小的应用<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#id2" title="永久链接至标题">¶</a></h2>
<p>一个最小的 Flask 应用看起来是这样:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">'Hello World!'</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>把它保存为 <cite>hello.py</cite> （或是类似的），然后用 Python 解释器来运行。
但是确保你的应用没有命名为 <cite>flask.py</cite> ，因为这将与 Flask 本身冲突。</p>
<div class="highlight-python"><pre>$ python hello.py
 * Running on http://127.0.0.1:5000/</pre>
</div>
<p>现在访问 <a class="reference external" href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a> ，你会看见 hello world 问候。</p>
<p>那么，这段代码做了什么？</p>
<ol class="arabic simple">
<li>首先，我们导入了 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> 类。这个类的实例将会是我们的 WSGI 应用程序。</li>
<li>接下来，我们创建一个该类的实例，第一个参数是应用模块或者包的名称。
如果你使用单一的模块（如本例），你应该使用 <cite>__name__</cite> ，因为取决于作为单独应用启动或者模块导入，它的名称将会不同（ <tt class="docutils literal"><span class="pre">'__main__'</span></tt>
相对实际的导入名称）。这是必须的，这样Flask 才会知道到哪里去寻找模板、
静态文件等等。详情参见 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> 的文档。</li>
<li>然后，我们使用 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> 装饰器告诉 Flask 什么样的
URL 应该触发我们的函数。</li>
<li>这个函数的名字也用作给特定的函数生成 URL，并且返回我们想要显示在用户浏览器中的信息。</li>
<li>最后我们用 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.run" title="flask.Flask.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> 函数来让应用运行在本地服务器上。
其中 <tt class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></tt> 确保服务器只会在该脚本被
Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。</li>
</ol>
<p>要停止服务器，按 Ctrl+C。</p>
<div class="admonition- admonition" id="public-server">
<p class="first admonition-title">可外部访问的服务器</p>
<p>如果你运行服务器，你会注意到它只能从你自己的计算机上访问，网络中其它任何的地方都不能访问。这是在默认情况，因为在调试模式，用户可以在你的计算机上执行任意 Python 代码。</p>
<p>如果你禁用了 <cite>debug</cite> 或信任你所在网络的用户，你可以简单修改调用
<a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.run" title="flask.Flask.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> 的方法使你的服务器公开可用，如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'0.0.0.0'</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">这会让操作系统监听所有公开的IP。</p>
</div>
</div>
<div class="section" id="debug-mode">
<span id="id3"></span><h2>调试模式<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#debug-mode" title="永久链接至标题">¶</a></h2>
<p>虽然 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.run" title="flask.Flask.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> 方法适用于本地开发服务器的启动，但是你每次修改代码后都要手动重启它。这样并不是很好，然而 Flask 可以做得更好。如果你启用了调试支持，服务器会在代码变更时自动重新载入，并且如果发生错误，它会提供一个有用的调试器。</p>
<p>有两种途径来启用调试模式。一种是在应用对象上设置:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>另一种是作为 run 方法的一个参数传入:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>两种方法的效果完全相同。</p>
<div class="admonition- admonition">
<p class="first admonition-title">注意</p>
<p class="last">尽管交互式调试器不能在 forking 环境（即在生产服务器上使用几乎是不可能的），它依然允许执行任意代码。这使它成为一个巨大的安全隐患，因此它  <strong>绝对不能用于生产环境</strong> 。</p>
</div>
<p>运行中的调试器截图：</p>
<img alt="screenshot of debugger in action" class="screenshot align-center" src="./flask0.10_files/debugger.png">
<p>想用另一个调试器？ 参见 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/errorhandling.html#working-with-debuggers"><em>调试器操作</em></a> 。</p>
</div>
<div class="section" id="id4">
<h2>路由<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#id4" title="永久链接至标题">¶</a></h2>
<p>现代 web 应用使用优雅的 URL，这易于人们记住 URL ，这点在面向使用慢网络连接的移动设备的应用上特别有用。如果可以不访问索引页而直接访问想要的页面，他们多半会喜欢这个页面而再度光顾。</p>
<p>如上所见， <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> 装饰器把一个函数绑定到对应的 URL 上。
这里是一些基本的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">'Index Page'</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/hello'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">'Hello World'</span>
</pre></div>
</div>
<p>但是，不仅如此！你可以构造特定部分动态的 URL，也可以在一个函数上附加多个规则。</p>
<div class="section" id="id5">
<h3>变量规则<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#id5" title="永久链接至标题">¶</a></h3>
<p>要给 URL 添加变量部分，你可以把这些特殊的字段标记为 <tt class="docutils literal"><span class="pre">&lt;variable_name&gt;</span></tt> ，
这个部分将会作为命名参数传递到你的函数。规则可以用
<tt class="docutils literal"><span class="pre">&lt;converter:variable_name&gt;</span></tt> 指定一个可选的转换器。这里有一些不错的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/user/&lt;username&gt;'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_user_profile</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="c"># show the user profile for that user</span>
    <span class="k">return</span> <span class="s">'User </span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">username</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/post/&lt;int:post_id&gt;'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_post</span><span class="p">(</span><span class="n">post_id</span><span class="p">):</span>
    <span class="c"># show the post with the given id, the id is an integer</span>
    <span class="k">return</span> <span class="s">'Post </span><span class="si">%d</span><span class="s">'</span> <span class="o">%</span> <span class="n">post_id</span>
</pre></div>
</div>
<p>现有的转换器如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%">
<col width="80%">
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>int</cite></td>
<td>接受整数</td>
</tr>
<tr class="row-even"><td><cite>float</cite></td>
<td>同 <cite>int</cite> ，但是接受浮点数</td>
</tr>
<tr class="row-odd"><td><cite>path</cite></td>
<td>和默认的相似，但也接受斜线</td>
</tr>
</tbody>
</table>
<div class="admonition- admonition">
<p class="first admonition-title">唯一的网址 / 重定向行为</p>
<p>Flask 的 URL 规则基于 Werkzeug 的路由模块。这个模块背后的思想是基于 Apache
以及更早的 HTTP 服务器规定的先例，保证优雅且唯一的 URL。</p>
<p>以这两个规则为例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/projects/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">projects</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">'The project page'</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/about'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">about</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">'The about page'</span>
</pre></div>
</div>
<p>虽然它们看起来确实相似，但它们结尾斜线的使用在 URL <em>定义</em> 中不同。
第一种情况中，规范的 URL 指向 <cite>projects</cite> 尾端有一个斜线。这种感觉很像在文件系统中的文件夹。访问一个结尾不带斜线的 URL 会被
Flask 重定向到带斜线的规范 URL 去。</p>
<p>然而，第二种情况的 URL 结尾不带斜线，类似 UNIX-like 系统下的文件的路径名。访问结尾带斜线的 URL 会产生一个 404 “Not Found” 错误。</p>
<p class="last">当用户访问页面时忘记结尾斜线时，这个行为允许关联的 URL 继续工作，并且与 Apache 和其它的服务器的行为一致。另外，URL 会保持唯一，有助于避免搜索引擎索引同一个页面两次。</p>
</div>
</div>
<div class="section" id="url">
<span id="url-building"></span><h3>构建 URL<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#url" title="永久链接至标题">¶</a></h3>
<p>如果它能匹配 URL ，那么 Flask 可以生成它们吗？当然可以。你可以使用
<a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> 来给一个特定函数构造 URL。它接受一个函数名作为第一个参数和一些关键字参数，每个对应 URL 规则的变量部分。未知变量部分会添加到 URL 末尾作为查询参数。这里是一些例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">url_for</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">index</span><span class="p">():</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/login'</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">login</span><span class="p">():</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/user/&lt;username&gt;'</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="n">username</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">():</span>
<span class="gp">... </span> <span class="k">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s">'index'</span><span class="p">)</span>
<span class="gp">... </span> <span class="k">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s">'login'</span><span class="p">)</span>
<span class="gp">... </span> <span class="k">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s">'login'</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="s">'/'</span><span class="p">)</span>
<span class="gp">... </span> <span class="k">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s">'profile'</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s">'John Doe'</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">/</span>
<span class="go">/login</span>
<span class="go">/login?next=/</span>
<span class="go">/user/John%20Doe</span>
</pre></div>
</div>
<p>（这里也用到了 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><tt class="xref py py-meth docutils literal"><span class="pre">test_request_context()</span></tt></a> 方法，下面会解释。即使我们正在通过 Python 的 shell 进行交互，它依然会告诉 Flask 像对待请求一样处理。
请看下面的解释。 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#context-locals"><em>局部上下文</em></a> ）</p>
<p>为什么你会想要构建 URL 而非在模板中硬编码？这里有三个好理由：</p>
<ol class="arabic simple">
<li>反向构建通常比硬编码更具备描述性。更重要的是，它允许你一次性修改 URL，
而不是到处找 URL 改。</li>
<li>URL 构建会显式地处理特殊字符和 Unicode 数据的转义，所以你不需要亲自处理。</li>
<li>如果你的应用不位于 URL 的根路径（比如，在 <tt class="docutils literal"><span class="pre">/myapplication</span></tt> 而不是 <tt class="docutils literal"><span class="pre">/</span></tt>
）， <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> 会为你妥善地处理这些。</li>
</ol>
</div>
<div class="section" id="http">
<h3>HTTP 方法<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#http" title="永久链接至标题">¶</a></h3>
<p>HTTP （web 应用会话的协议）知道访问 URL 的不同方法。默认情况下，路由只回应
<cite>GET</cite> 请求，但是通过给 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> 装饰器提供 <cite>methods</cite> 参数可以更改这个行为。这里有一些例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/login'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'GET'</span><span class="p">,</span> <span class="s">'POST'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">'POST'</span><span class="p">:</span>
        <span class="n">do_the_login</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">show_the_login_form</span><span class="p">()</span>
</pre></div>
</div>
<p>如果当前是 <cite>GET</cite> 请求， 它也会自动的为你添加`HEAD`，无需你操心。它会确保 <cite>HEAD</cite>
请求按照 <a class="reference external" href="http://www.ietf.org/rfc/rfc2068.txt">HTTP RFC</a> （描述 HTTP 协议的文档）来处理，所以你可以完全忽略这部分的 HTTP 规范。同样，自从 Flask 0.6 起， <cite>OPTIONS</cite> 也实现了自动处理。</p>
<p>你不知道一个 HTTP 方法是什么？不必担心，这里快速介绍 HTTP 方法和它们为什么重要：</p>
<p>HTTP 方法（也经常被叫做“谓词”）告诉服务器客户端想对请求的页面 <em>做</em> 什么。
以下都是非常常见的方法：</p>
<dl class="docutils">
<dt><cite>GET</cite></dt>
<dd>浏览器告诉服务器，只 <em>获取</em> 页面上的信息并发给我。这是最常用的方法。</dd>
<dt><cite>HEAD</cite></dt>
<dd>浏览器告诉服务器获取信息，但是只对 <em>消息头</em> 感兴趣。应用期望像 <cite>GET</cite> 请求
一样处理它，但是不传递实际内容。在 Flask 中你完全不用处理它，底层的
Werkzeug 库已经替你处理好了。</dd>
<dt><cite>POST</cite></dt>
<dd>浏览器告诉服务器，它想在 URL 上 <em>发布</em> 新信息。并且，服务器必须确保数据已
存储且只存储一次。这是 HTML 表单通常发送数据到服务器的方法。</dd>
<dt><cite>PUT</cite></dt>
<dd>类似 <cite>POST</cite> 但是服务器可能触发了存储过程多次，多次覆盖掉旧值。你可能会问这
有什么用，当然这是有原因的。考虑到传输中连接可能会丢失，在这种情况下浏览器
和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。使用 <cite>POST</cite>
不能实现，因为它只会被触发一次。</dd>
<dt><cite>DELETE</cite></dt>
<dd>删除给定位置的信息。</dd>
<dt><cite>OPTIONS</cite></dt>
<dd>给客户端提供一个快速的途径来弄清这个 URL 支持哪些 HTTP 方法。从 Flask 0.6 开
始，自动实现了它。</dd>
</dl>
<p>有趣的是，在 HTML4 和 XHTML1 中，表单只能以 <cite>GET</cite> 和 <cite>POST</cite> 方法提交到服务器。
但是用 JavaScript 和未来的 HTML 标准允许你使用其它所有的方法。此外，HTTP 最近变得相当流行，浏览器不再是唯一的 HTTP 客户端。例如，许多版本控制系统也在用它。</p>
</div>
</div>
<div class="section" id="id6">
<h2>静态文件<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#id6" title="永久链接至标题">¶</a></h2>
<p>动态 web 应用也会需要静态文件，通常是 CSS 和 JavaScript 文件的存放位置。理想情况下，
你已经配置 web 服务器来提供它们，但是在开发中， Flask 也可以做到。只要在你的包中或模块旁边创建一个名为 <cite>static</cite> 的文件夹，在应用中使用 <cite>/static</cite> 即可访问。</p>
<p>给静态文件生成 URL ，使用特殊的 <tt class="docutils literal"><span class="pre">'static'</span></tt> 端点名:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">url_for</span><span class="p">(</span><span class="s">'static'</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">'style.css'</span><span class="p">)</span>
</pre></div>
</div>
<p>这个文件应该存储在文件系统上的 <tt class="docutils literal"><span class="pre">static/style.css</span></tt> 。</p>
</div>
<div class="section" id="id7">
<h2>模板渲染<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#id7" title="永久链接至标题">¶</a></h2>
<p>在 Python 里生成 HTML 十分无趣，而且相当繁琐，因为你需要自行对 HTML 做转义来保证应用安全。由于这个原因， Flask 自动配置了
<a class="reference external" href="http://jinja.pocoo.org/2/">Jinja2</a> 模板引擎。</p>
<p>你可以使用 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.render_template" title="flask.render_template"><tt class="xref py py-func docutils literal"><span class="pre">render_template()</span></tt></a> 方法来渲染模板。你需要做的所有事就是将模板名和你想作为关键字的参数传入模板的变量。这里有一个描述如何渲染模板的简例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">render_template</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/hello/'</span><span class="p">)</span>
<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/hello/&lt;name&gt;'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">'hello.html'</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>Flask 会在 <cite>templates</cite> 文件夹里寻找模板。所以，如果你的应用是个模块，这个文件夹在模块的旁边；如果它是一个包，那么这个文件夹在你的包里面:</p>
<p><strong>情况 1</strong>: 模块:</p>
<div class="highlight-python"><pre>/application.py
/templates
    /hello.html</pre>
</div>
<p><strong>情况 2</strong>: 包:</p>
<div class="highlight-python"><pre>/application
    /__init__.py
    /templates
        /hello.html</pre>
</div>
<p>对于模板，你可以使用 Jinja2 模板的全部能力。更多信息请见官方的 <a class="reference external" href="http://jinja.pocoo.org/2/documentation/templates">Jinja2 模板文档</a> 。</p>
<p>这里是一个模板实例：</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">&lt;!doctype html&gt;</span>
<span class="nt">&lt;title&gt;</span>Hello from Flask<span class="nt">&lt;/title&gt;</span>
<span class="cp">{%</span> <span class="k">if</span> <span class="nv">name</span> <span class="cp">%}</span>
  <span class="nt">&lt;h1&gt;</span>Hello <span class="cp">{{</span> <span class="nv">name</span> <span class="cp">}}</span>!<span class="nt">&lt;/h1&gt;</span>
<span class="cp">{%</span> <span class="k">else</span> <span class="cp">%}</span>
  <span class="nt">&lt;h1&gt;</span>Hello World!<span class="nt">&lt;/h1&gt;</span>
<span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>在模板里，你也可以访问 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> 、 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.session" title="flask.session"><tt class="xref py py-class docutils literal"><span class="pre">session</span></tt></a> 和
<a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.g" title="flask.g"><tt class="xref py py-class docutils literal"><span class="pre">g</span></tt></a> <a class="footnote-reference" href="http://docs.jinkan.org/docs/flask/quickstart.html#id10" id="id9">[1]</a> 对象，以及 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></tt></a> 函数。</p>
<p>使用继承，模板会相当有用。如果你想知道继承如何工作，请跳转到
<a class="reference internal" href="http://docs.jinkan.org/docs/flask/patterns/templateinheritance.html#template-inheritance"><em>模板继承</em></a> 模式文档。基本的模板继承使得特定元素（比如页眉、导航栏和页脚）可以出现在所有的页面。</p>
<p>自动转义默认是开启的，所以如果 <cite>name</cite> 包含 HTML ，它将会被自动转义。如果你能信任一个变量，并且你知道它是安全的（例如一个模块把 wiki 标记转换到 HTML ），你可以用
<tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt> 类或 <tt class="docutils literal"><span class="pre">|safe</span></tt> 过滤器在模板中标记它是安全的。在 Jinja 2
文档中，你会见到更多例子。</p>
<p>这里是一个 <tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt> 类如何工作的基本介绍:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Markup</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">'&lt;strong&gt;Hello </span><span class="si">%s</span><span class="s">!&lt;/strong&gt;'</span><span class="p">)</span> <span class="o">%</span> <span class="s">'&lt;blink&gt;hacker&lt;/blink&gt;'</span>
<span class="go">Markup(u'&lt;strong&gt;Hello &amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;!&lt;/strong&gt;')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s">'&lt;blink&gt;hacker&lt;/blink&gt;'</span><span class="p">)</span>
<span class="go">Markup(u'&amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">'&lt;em&gt;Marked up&lt;/em&gt; &amp;raquo; HTML'</span><span class="p">)</span><span class="o">.</span><span class="n">striptags</span><span class="p">()</span>
<span class="go">u'Marked up \xbb HTML'</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span>在 0.5 版更改: </span>自动转义不再在所有模板中启用。下列扩展名的模板会触发自动转义： <tt class="docutils literal"><span class="pre">.html</span></tt> 、
<tt class="docutils literal"><span class="pre">.htm</span></tt> 、<tt class="docutils literal"><span class="pre">.xml</span></tt> 、 <tt class="docutils literal"><span class="pre">.xhtml</span></tt> 。从字符串加载的模板会禁用自动转义。</p>
</div>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="http://docs.jinkan.org/docs/flask/quickstart.html#id9">[1]</a></td><td>不确定 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.g" title="flask.g"><tt class="xref py py-class docutils literal"><span class="pre">g</span></tt></a> 对象是什么？它是你可以按需存储信息的东西，
查看（ <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.g" title="flask.g"><tt class="xref py py-class docutils literal"><span class="pre">g</span></tt></a> ）对象的文档和 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/patterns/sqlite3.html#sqlite3"><em>在 Flask 中使用 SQLite 3</em></a> 的文档以获取更多信息。</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id11">
<h2>访问请求数据<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#id11" title="永久链接至标题">¶</a></h2>
<p>对于 web 应用，对客户端发送给服务器的数据做出反应至关重要。在 Flask 中由全局的 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> 对象来提供这些信息。如果你有一定的 Python 经验，你会好奇这个对象怎么可能是全局的，并且 Flask 是怎么还能保证线程安全。答案是上下文作用域:</p>
<div class="section" id="context-locals">
<span id="id12"></span><h3>局部上下文<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#context-locals" title="永久链接至标题">¶</a></h3>
<div class="admonition- admonition">
<p class="first admonition-title">内幕</p>
<p class="last">如果你想理解它是如何工作以及如何实现测试，请阅读此节，否则可跳过。</p>
</div>
<p>Flask 中的某些对象是全局对象，但不是通常的类型。这些对象实际上是给定上下文的局部对象的代理。虽然很拗口，但实际上很容易理解。</p>
<p>想象一下处理线程的上下文。一个请求传入，web 服务器决定生成一个新线程（或者别的什么东西，只要这个基础对象可以胜任并发系统，而不仅仅是线程）。当 Flask 开始它内部请求处理时，它认定当前线程是活动的上下文并绑定当前的应用和 WSGI 环境到那个上下文（线程）。它以一种智能的方法来实现，以保证一个应用调用另一个应用时不会中断。</p>
<p>所以这对你来说意味着什么？除非你要做类似单元测试的东西，基本上可以完全忽略这种情况。你会发现依赖于一个请求对象的代码会突然中断，因为不会有请求对象。解决方案是自己创建一个请求对象并且把它绑定到上下文。单元测试的最早的解决方案是使用 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><tt class="xref py py-meth docutils literal"><span class="pre">test_request_context()</span></tt></a> 上下文管理器。结合 <cite>with</cite> 声明，它将绑定一个测试请求来进行交互。这里是一个例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">(</span><span class="s">'/hello'</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'POST'</span><span class="p">):</span>
    <span class="c"># now you can do something with the request until the</span>
    <span class="c"># end of the with block, such as basic assertions:</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="s">'/hello'</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">'POST'</span>
</pre></div>
</div>
<p>另一种可能是传递整个 WSGI 环境给 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.request_context" title="flask.Flask.request_context"><tt class="xref py py-meth docutils literal"><span class="pre">request_context()</span></tt></a> 方法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">'POST'</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h3>请求对象<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#id13" title="永久链接至标题">¶</a></h3>
<p>请求对象在 API 章节有详细的描述（参见 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> ），这里不会赘述。这里宽泛介绍一些最常用的操作。首先你需要从 <cite>flask</cite> 模块里导入它:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>
</pre></div>
</div>
<p>当前的请求方式通过 <tt class="xref py py-attr docutils literal"><span class="pre">method</span></tt> 属性来访问。通过
<tt class="xref py py-attr docutils literal"><span class="pre">form</span></tt> 属性来访问表单数据（ <cite>POST</cite> 或 <cite>PUT</cite> 请求提交的数据）。这里有一个上面提到的两个属性的完整实例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">'/login'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'POST'</span><span class="p">,</span> <span class="s">'GET'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">'POST'</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valid_login</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">'username'</span><span class="p">],</span>
                       <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">'password'</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">log_the_user_in</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">'username'</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="s">'Invalid username/password'</span>
    <span class="c"># the code below is executed if the request method</span>
    <span class="c"># was GET or the credentials were invalid</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">'login.html'</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p>当 <cite>form</cite> 属性中的键值不存在会发生什么？在这种情况，一个特殊的
<a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#KeyError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> 异常会抛出。你可以像捕获标准的 <a class="reference external" href="http://docs.python.org/dev/library/exceptions.html#KeyError" title="(在 Python v3.5)"><tt class="xref py py-exc docutils literal"><span class="pre">KeyError</span></tt></a> 来捕获它。
如果你不这么做，它会显示一个 HTTP 400 Bad Request 错误页面。所以，很多情况下你并不需要处理这个问题。</p>
<p>你可以通过 <tt class="xref py py-attr docutils literal"><span class="pre">args</span></tt> 属性来访问 URL 中提交的参数
（ <tt class="docutils literal"><span class="pre">?key=value</span></tt> ）:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">searchword</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'q'</span><span class="p">,</span> <span class="s">''</span><span class="p">)</span>
</pre></div>
</div>
<p>我们推荐使用 <cite>get</cite> 来访问 URL 参数或捕获 <cite>KeyError</cite> ，因为用户可能会修改 URL ，
向他们展现一个 400 bad request 页面会影响用户体验。</p>
<p>想获取请求对象的完整方法和属性清单，请参阅 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> 的文档。</p>
</div>
<div class="section" id="id14">
<h3>文件上传<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#id14" title="永久链接至标题">¶</a></h3>
<p>你可以很容易的用 Flask 处理文件上传。只需要确保没忘记在你的 HTML 表单中设置
<tt class="docutils literal"><span class="pre">enctype="multipart/form-data"</span></tt> 属性，否则你的浏览器将根本不提交文件。</p>
<p>已上传的文件存储在内存或是文件系统上的临时位置。你可以通过请求对象的
<tt class="xref py py-attr docutils literal"><span class="pre">files</span></tt> 属性访问那些文件。每个上传的文件都会存储在那个字典里。它表现得如同一个标准的 Python <tt class="xref py py-class docutils literal"><span class="pre">file</span></tt> 对象，但它还有一个
<a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.FileStorage.save" title="(在 Werkzeug v0.10)"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a> 方法来允许你在服务器的文件系统上保存它。这里是一个它如何工作的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/upload'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'GET'</span><span class="p">,</span> <span class="s">'POST'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">upload_file</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">'POST'</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">'the_file'</span><span class="p">]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">'/var/www/uploads/uploaded_file.txt'</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>如果你想知道上传前文件在客户端的文件名，你可以访问
<a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.FileStorage.filename" title="(在 Werkzeug v0.10)"><tt class="xref py py-attr docutils literal"><span class="pre">filename</span></tt></a> 属性。但请记住永远不要信任这个值，因为这个值可以伪造。如果你想要使用客户端的文件名来在服务器上存储文件，把它传递给 Werkzeug 提供的
<a class="reference external" href="http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename" title="(在 Werkzeug v0.10)"><tt class="xref py py-func docutils literal"><span class="pre">secure_filename()</span></tt></a> 函数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>
<span class="kn">from</span> <span class="nn">werkzeug</span> <span class="kn">import</span> <span class="n">secure_filename</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/upload'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'GET'</span><span class="p">,</span> <span class="s">'POST'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">upload_file</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">'POST'</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">'the_file'</span><span class="p">]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">'/var/www/uploads/'</span> <span class="o">+</span> <span class="n">secure_filename</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>一些更好的例子，查看 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/patterns/fileuploads.html#uploading-files"><em>上传文件</em></a> 模式。</p>
</div>
<div class="section" id="cookies">
<h3>Cookies<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#cookies" title="永久链接至标题">¶</a></h3>
<p>你可以通过 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Request.cookies" title="flask.Request.cookies"><tt class="xref py py-attr docutils literal"><span class="pre">cookies</span></tt></a> 属性来访问 cookies 。设置
cookies 通过响应对象的 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Response.set_cookie" title="flask.Response.set_cookie"><tt class="xref py py-attr docutils literal"><span class="pre">set_cookie</span></tt></a> 方法。请求对象的 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Request.cookies" title="flask.Request.cookies"><tt class="xref py py-attr docutils literal"><span class="pre">cookies</span></tt></a> 属性是一个客户端提交的所有 cookies 的字典。如果你想使用会话，请不要直接使用 cookies，请参考 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#sessions"><em>会话</em></a>
一节。在 Flask 中，已经在 cookies 上增加了一些安全细节。</p>
<p>读取 cookies:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">request</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">cookies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'username'</span><span class="p">)</span>
    <span class="c"># use cookies.get(key) instead of cookies[key] to not get a</span>
    <span class="c"># KeyError if the cookie is missing.</span>
</pre></div>
</div>
<p>存储 cookies:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">make_response</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s">'username'</span><span class="p">,</span> <span class="s">'the username'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resp</span>
</pre></div>
</div>
<p>注意 cookies 是设置在响应对象上。由于通常只是从视图函数返回字符串，
Flask 会将其转换为响应对象。如果你显式地想要这么做，你可以使用
<a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.make_response" title="flask.make_response"><tt class="xref py py-meth docutils literal"><span class="pre">make_response()</span></tt></a> 函数然后修改它。</p>
<p>有时候你会想要在响应对象不存在的时候设置 cookie ，这在利用
<a class="reference internal" href="http://docs.jinkan.org/docs/flask/patterns/deferredcallbacks.html#deferred-callbacks"><em>延迟请求回调</em></a> 模式时是可行的。</p>
<p>为此也可以参阅 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#about-responses"><em>关于响应</em></a> 。</p>
</div>
</div>
<div class="section" id="id15">
<h2>重定向和错误<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#id15" title="永久链接至标题">¶</a></h2>
<p>重定向用户到其它地方你可以使用 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.redirect" title="flask.redirect"><tt class="xref py py-func docutils literal"><span class="pre">redirect()</span></tt></a> 函数。放弃请求并返回错误代码可以使用 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.abort" title="flask.abort"><tt class="xref py py-func docutils literal"><span class="pre">abort()</span></tt></a> 函数。这里是一个它们如何工作的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">abort</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">'login'</span><span class="p">))</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/login'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">abort</span><span class="p">(</span><span class="mi">401</span><span class="p">)</span>
    <span class="n">this_is_never_executed</span><span class="p">()</span>
</pre></div>
</div>
<p>这是一个相当无意义的例子因为用户会从主页重定向到一个不能访问的页面（401意味着禁止访问），但是它说明了重定向如何工作。</p>
<p>默认情况下，每个错误代码会显示一个黑白错误页面。如果你想定制错误页面，可以使用 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></tt></a> 装饰器:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">render_template</span>

<span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">'page_not_found.html'</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p>注意 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.render_template" title="flask.render_template"><tt class="xref py py-func docutils literal"><span class="pre">render_template()</span></tt></a> 调用之后的 <tt class="docutils literal"><span class="pre">404</span></tt> 。这告诉 Flask 该页的错误代码应是 404 ，即没有找到。默认的 200 被假定为：一切正常。</p>
</div>
<div class="section" id="about-responses">
<span id="id16"></span><h2>关于响应<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#about-responses" title="永久链接至标题">¶</a></h2>
<p>视图函数的返回值会被自动转换为一个响应对象。如果返回值是一个字符串，
它被转换为响应主体为该字符串、状态码为 <tt class="docutils literal"><span class="pre">200</span> <span class="pre">OK</span></tt> 、 MIME 类型为
<tt class="docutils literal"><span class="pre">text/html</span></tt> 的响应对象。Flask 把返回值转换为响应对象的逻辑如下：</p>
<ol class="arabic simple">
<li>如果返回的是一个合法的响应对象，它会被从视图直接返回。</li>
<li>如果返回的是一个字符串，响应对象会用字符串数据和默认参数创建。</li>
<li>如果返回的是一个元组，且元组中的元素可以提供额外的信息。这样的元组必须是 <tt class="docutils literal"><span class="pre">(response,</span> <span class="pre">status,</span> <span class="pre">headers)</span></tt> 这样的形式，且至少包含一个元素。
<cite>status</cite> 值会覆盖状态代码， <cite>headers</cite> 可以是一个列表或字典，作为额外的消息头值。</li>
<li>如果上述条件均不满足， Flask 会假设返回值是一个合法的 WSGI 应用程序，
并转换为一个请求对象。</li>
</ol>
<p>如果你想在视图里掌控上述步骤结果的响应对象，你可以使用
<a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.make_response" title="flask.make_response"><tt class="xref py py-func docutils literal"><span class="pre">make_response()</span></tt></a> 函数。</p>
<p>想象你有这样一个视图:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">'error.html'</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p>你只需要用 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.make_response" title="flask.make_response"><tt class="xref py py-func docutils literal"><span class="pre">make_response()</span></tt></a> 封装返回表达式，获取结果对象并修改，然后返回它:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="s">'error.html'</span><span class="p">),</span> <span class="mi">404</span><span class="p">)</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s">'X-Something'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'A value'</span>
    <span class="k">return</span> <span class="n">resp</span>
</pre></div>
</div>
</div>
<div class="section" id="sessions">
<span id="id17"></span><h2>会话<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#sessions" title="永久链接至标题">¶</a></h2>
<p>除请求对象之外，还有 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.session" title="flask.session"><tt class="xref py py-class docutils literal"><span class="pre">session</span></tt></a> 对象允许你在不同请求间存储特定用户的信息。这是在 cookies 的基础上实现的，并且在 cookies 中使用加密的签名。这意味着用户可以查看你 cookie 的内容，但是不能修改它，除非它知道签名的密钥。</p>
<p>要使用会话，你需要设置一个密钥。这里介绍会话如何工作:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span><span class="p">,</span> <span class="n">escape</span><span class="p">,</span> <span class="n">request</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">if</span> <span class="s">'username'</span> <span class="ow">in</span> <span class="n">session</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">'Logged in as </span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">escape</span><span class="p">(</span><span class="n">session</span><span class="p">[</span><span class="s">'username'</span><span class="p">])</span>
    <span class="k">return</span> <span class="s">'You are not logged in'</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/login'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'GET'</span><span class="p">,</span> <span class="s">'POST'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">'POST'</span><span class="p">:</span>
        <span class="n">session</span><span class="p">[</span><span class="s">'username'</span><span class="p">]</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">'username'</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">'index'</span><span class="p">))</span>
    <span class="k">return</span> <span class="s">'''</span>
<span class="s">        &lt;form action="" method="post"&gt;</span>
<span class="s">            &lt;p&gt;&lt;input type=text name=username&gt;</span>
<span class="s">            &lt;p&gt;&lt;input type=submit value=Login&gt;</span>
<span class="s">        &lt;/form&gt;</span>
<span class="s">    '''</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">'/logout'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logout</span><span class="p">():</span>
    <span class="c"># remove the username from the session if it's there</span>
    <span class="n">session</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'username'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">'index'</span><span class="p">))</span>

<span class="c"># set the secret key.  keep this really secret:</span>
<span class="n">app</span><span class="o">.</span><span class="n">secret_key</span> <span class="o">=</span> <span class="s">'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'</span>
</pre></div>
</div>
<p>这里提到的 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.escape" title="flask.escape"><tt class="xref py py-func docutils literal"><span class="pre">escape()</span></tt></a> 可以在你不使用模板引擎的时候做转义（如同本例）。</p>
<div class="admonition- admonition">
<p class="first admonition-title">如何生成一个强壮的密钥</p>
<p>随机的问题在于很难判断什么是真随机。一个密钥应该足够随机。你的操作系统可以基于一个密码随机生成器来生成漂亮的随机值，这个值可以用来做密钥:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="go">'\xfd{H\xe5&lt;\x95\xf9\xe3\x96.5\xd1\x01O&lt;!\xd5\xa2\xa0\x9fR"\xa1\xa8'</span>
</pre></div>
</div>
<p class="last">把这个值复制粘贴到你的代码，你就搞定了密钥。</p>
</div>
<p>使用基于 cookie 的会话需注意: Flask 会将你放进会话对象的值序列化到 cookie。
如果你发现某些值在请求之间并没有持久化保存，而 cookies 确实已经启用了，你也没有得到明确的错误信息，请检查你的页面响应中的 cookie 的大小，并与 web 浏览器所支持的大小对比。</p>
</div>
<div class="section" id="id18">
<h2>消息闪现<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#id18" title="永久链接至标题">¶</a></h2>
<p>良好的应用和用户界面全部涉及反馈。如果用户得不到足够的反馈，他们很可能开始厌恶这个应用。 Flask 提供一种消息闪现系统给用户反馈的简单方法。
消息闪现系统通常会在请求结束时记录信息，并在下一个（且仅在下一个）请求中访问。通常结合模板布局来展现消息。</p>
<p>使用 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.flash" title="flask.flash"><tt class="xref py py-func docutils literal"><span class="pre">flash()</span></tt></a> 方法可以闪现一条消息。要掌控消息本身，使用
<a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></tt></a> 函数，并且在模板中也可以使用。完整的例子请查阅 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/patterns/flashing.html#message-flashing-pattern"><em>消息闪现</em></a> 部分。</p>
</div>
<div class="section" id="id19">
<h2>日志记录<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#id19" title="永久链接至标题">¶</a></h2>
<div class="versionadded">
<p><span>0.3 新版功能.</span></p>
</div>
<p>有时候你处于一种境地，你处理的数据本应该是正确的，但实际上不是。比如你有一些客户端代码向服务器发送请求，但请求显然是畸形的。这可能是用户篡改了数据，或是客户端代码的失败。大多数情况下，正常地返回 <tt class="docutils literal"><span class="pre">400</span> <span class="pre">Bad</span> <span class="pre">Request</span></tt> 就可以了，
但是有时不这么做，并且代码要继续运行。</p>
<p>你可能依然想要记录发生了什么不对劲。这时日志记录就派上了用场。Flask 0.3
开始已经预置了日志系统。</p>
<p>这里有一些日志调用的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">'A value for debugging'</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">'A warning occurred (</span><span class="si">%d</span><span class="s"> apples)'</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">'An error occurred'</span><span class="p">)</span>
</pre></div>
</div>
<p>附带的 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/api.html#flask.Flask.logger" title="flask.Flask.logger"><tt class="xref py py-attr docutils literal"><span class="pre">logger</span></tt></a> 是一个标准日志类
<a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging.Logger" title="(在 Python v3.5)"><tt class="xref py py-class docutils literal"><span class="pre">Logger</span></tt></a> ，所以更多信息请见 <a class="reference external" href="http://docs.python.org/library/logging.html">logging
文档</a> 。</p>
</div>
<div class="section" id="wsgi">
<h2>整合 WSGI 中间件<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#wsgi" title="永久链接至标题">¶</a></h2>
<p>如果你想给你的应用添加 WSGI 中间件，你可以封装内部 WSGI 应用。例如如果你想使用 Werkzeug 包中的某个中间件来应付 lighttpd 中的 bugs ，可以这样做:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug.contrib.fixers</span> <span class="kn">import</span> <span class="n">LighttpdCGIRootFix</span>
<span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">LighttpdCGIRootFix</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="web">
<span id="quickstart-deployment"></span><h2>部署到 Web 服务器<a class="headerlink" href="http://docs.jinkan.org/docs/flask/quickstart.html#web" title="永久链接至标题">¶</a></h2>
<p>准备好部署你的 Flask 应用了？你可以立即部署到托管平台来圆满完成快速入门，
以下均向小项目提供免费的方案:</p>
<ul class="simple">
<li><a class="reference external" href="http://devcenter.heroku.com/articles/python">在 Heroku 上部署 Flask</a></li>
<li><a class="reference external" href="http://docs.dotcloud.com/services/python/">在 dotCloud 上部署 Flask</a>
附 <a class="reference external" href="http://flask.pocoo.org/snippets/48/">Flask 的具体说明</a></li>
</ul>
<p>托管 Flask 应用的其它选择:</p>
<ul class="simple">
<li><a class="reference external" href="http://flask.pocoo.org/snippets/65/">在 Webfaction 上部署 Flask</a></li>
<li><a class="reference external" href="https://github.com/kamalgill/flask-appengine-template">在 Google App Engine 上部署 Flask</a></li>
<li><a class="reference external" href="http://flask.pocoo.org/snippets/89/">用 Localtunnel 共享你的本地服务器</a></li>
</ul>
<p>如果你管理自己的主机并且想要亲自运行，参见 <a class="reference internal" href="http://docs.jinkan.org/docs/flask/deploying/index.html#deployment"><em>部署选择</em></a> 章节。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><p class="logo"><a href="http://docs.jinkan.org/docs/flask/index.html">
  <img class="logo" src="./flask0.10_files/flask.png" alt="Logo">
</a></p>
  <h3><a href="http://docs.jinkan.org/docs/flask/index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#">快速入门</a><ul>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#id2">一个最小的应用</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#debug-mode">调试模式</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#id4">路由</a><ul>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#id5">变量规则</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#url">构建 URL</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#http">HTTP 方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#id6">静态文件</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#id7">模板渲染</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#id11">访问请求数据</a><ul>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#context-locals">局部上下文</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#id13">请求对象</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#id14">文件上传</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#cookies">Cookies</a></li>
</ul>
</li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#id15">重定向和错误</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#about-responses">关于响应</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#sessions">会话</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#id18">消息闪现</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#id19">日志记录</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#wsgi">整合 WSGI 中间件</a></li>
<li><a class="reference internal" href="http://docs.jinkan.org/docs/flask/quickstart.html#web">部署到 Web 服务器</a></li>
</ul>
</li>
</ul>
<h3>相关主题</h3>
<ul>
  <li><a href="http://docs.jinkan.org/docs/flask/index.html">文档概览</a><ul>
      <li>上一章：<a href="http://docs.jinkan.org/docs/flask/installation.html" title="上一章">安装</a></li>
      <li>下一章：<a href="http://docs.jinkan.org/docs/flask/tutorial/index.html" title="下一章">教程</a></li>
  </ul></li>
</ul>
  <h3>本页</h3>
  <ul class="this-page-menu">
    <li><a href="http://docs.jinkan.org/docs/flask/_sources/quickstart.txt" rel="nofollow">显示源代码</a></li>
  </ul>
<div id="searchbox">
  <h3>快速搜索</h3>
    <form class="search" action="http://docs.jinkan.org/docs/flask/search.html" method="get">
      <input type="text" name="q">
      <input type="submit" value="转向">
      <input type="hidden" name="check_keywords" value="yes">
      <input type="hidden" name="area" value="default">
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的术语，模块，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer">
    © Copyright 2013, Armin Ronacher.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  
  
</body></html>